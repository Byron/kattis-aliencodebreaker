use std::{process, io::{stdin, stdout, BufRead, BufWriter, Write}};

mod parse {
    use std::io;

    #[derive(Debug)]
    pub enum Error {
        InvalidDimensions(&'static str, String),
        InvalidCyphertext(&'static str, String),
        IO(io::Error),
    }

    impl From<io::Error> for Error {
        fn from(err: io::Error) -> Self {
            Error::IO(err)
        }
    }

    pub fn dimensions(input: &str) -> Result<(u32, u32), Error> {
        let mut ws = input.split_whitespace();
        match (ws.next(), ws.next()) {
            (Some(cls), Some(tss)) => Ok((
                {
                    let cl = cls.parse().map_err(|_| {
                        Error::InvalidDimensions("could not parse cypher length", input.to_owned())
                    })?;
                    if cl > 10u32.pow(6) || cl == 0 {
                        return Err(Error::InvalidDimensions(
                            "cipher text is too large or 0",
                            input.to_owned(),
                        ));
                    }
                    cl
                },
                {
                    let ts = tss.parse().map_err(|_| {
                        Error::InvalidDimensions("could not parse table size", input.to_owned())
                    })?;
                    if ts > 10u32.pow(5) || ts == 0 {
                        return Err(Error::InvalidDimensions(
                            "table size is too large or 0",
                            input.to_owned(),
                        ));
                    }
                    ts
                },
            )),
            _ => Err(Error::InvalidDimensions(
                "need two whitespace separated tokens",
                input.to_owned(),
            )),
        }
    }

    pub fn validated_cypher_text(input: &str, cypher_len: u32) -> Result<&str, Error> {
        if input.len() < cypher_len as usize {
            return Err(Error::InvalidCyphertext(
                "cypher text is shorter than advertised",
                input.to_owned(),
            ));
        }
        Ok(&input[..cypher_len as usize])
    }
}

mod crypt {
    use std::io;

    type UInt = u32;

    const MOD: UInt = 1048576;
    const MODUS: usize = MOD as usize;
    const BASE: u8 = 27;

    // All taken from num_bigint crate, modified to only the relevant code-paths
    mod big {
        pub enum ParseBigIntError {
            Empty,
            Invalid,
        }

        #[derive(Clone, Debug, Hash)]
        pub struct BigUint {
            data: Vec<BigDigit>,
        }

        mod big_digit {
            pub const BITS: usize = 32;
            pub type BigDigit = u32;
            pub type DoubleBigDigit = u64;

            #[inline]
            pub fn to_doublebigdigit(hi: BigDigit, lo: BigDigit) -> DoubleBigDigit {
                (lo as DoubleBigDigit) | ((hi as DoubleBigDigit) << BITS)
            }
        }
        use self::big_digit::*;

        fn from_radix_digits_be(v: &[u8], radix: u32) -> BigUint {
            debug_assert!(!v.is_empty() && !radix.is_power_of_two());
            debug_assert!(v.iter().all(|&c| (c as u32) < radix));

            // Estimate how big the result will be, so we can pre-allocate it.
            let bits = (radix as f64).log2() * v.len() as f64;
            let big_digits = (bits / big_digit::BITS as f64).ceil();
            let mut data = Vec::with_capacity(big_digits as usize);

            let (base, power) = get_radix_base(radix);
            let radix = radix as BigDigit;

            let r = v.len() % power;
            let i = if r == 0 { power } else { r };
            let (head, tail) = v.split_at(i);

            let first = head.iter().fold(0, |acc, &d| acc * radix + d as BigDigit);
            data.push(first);

            debug_assert!(tail.len() % power == 0);
            for chunk in tail.chunks(power) {
                if data.last() != Some(&0) {
                    data.push(0);
                }

                let mut carry = 0;
                for d in data.iter_mut() {
                    *d = mac_with_carry(0, *d, base, &mut carry);
                }
                debug_assert!(carry == 0);

                let n = chunk.iter().fold(0, |acc, &d| acc * radix + d as BigDigit);
                add2(&mut data, &[n]);
            }

            BigUint::new(data)
        }

        #[inline]
        fn get_radix_base(radix: u32) -> (BigDigit, usize) {
            debug_assert!(
                2 <= radix && radix <= 256,
                "The radix must be within 2...256"
            );
            debug_assert!(!radix.is_power_of_two());

            match big_digit::BITS {
                32 => {
                    const BASES: [(u32, usize); 257] = [
                        (0, 0),
                        (0, 0),
                        (0, 0),           //  2
                        (3486784401, 20), //  3
                        (0, 0),           //  4
                        (1220703125, 13), //  5
                        (2176782336, 12), //  6
                        (1977326743, 11), //  7
                        (0, 0),           //  8
                        (3486784401, 10), //  9
                        (1000000000, 9),  // 10
                        (2357947691, 9),  // 11
                        (429981696, 8),   // 12
                        (815730721, 8),   // 13
                        (1475789056, 8),  // 14
                        (2562890625, 8),  // 15
                        (0, 0),           // 16
                        (410338673, 7),   // 17
                        (612220032, 7),   // 18
                        (893871739, 7),   // 19
                        (1280000000, 7),  // 20
                        (1801088541, 7),  // 21
                        (2494357888, 7),  // 22
                        (3404825447, 7),  // 23
                        (191102976, 6),   // 24
                        (244140625, 6),   // 25
                        (308915776, 6),   // 26
                        (387420489, 6),   // 27
                        (481890304, 6),   // 28
                        (594823321, 6),   // 29
                        (729000000, 6),   // 30
                        (887503681, 6),   // 31
                        (0, 0),           // 32
                        (1291467969, 6),  // 33
                        (1544804416, 6),  // 34
                        (1838265625, 6),  // 35
                        (2176782336, 6),  // 36
                        (2565726409, 6),  // 37
                        (3010936384, 6),  // 38
                        (3518743761, 6),  // 39
                        (4096000000, 6),  // 40
                        (115856201, 5),   // 41
                        (130691232, 5),   // 42
                        (147008443, 5),   // 43
                        (164916224, 5),   // 44
                        (184528125, 5),   // 45
                        (205962976, 5),   // 46
                        (229345007, 5),   // 47
                        (254803968, 5),   // 48
                        (282475249, 5),   // 49
                        (312500000, 5),   // 50
                        (345025251, 5),   // 51
                        (380204032, 5),   // 52
                        (418195493, 5),   // 53
                        (459165024, 5),   // 54
                        (503284375, 5),   // 55
                        (550731776, 5),   // 56
                        (601692057, 5),   // 57
                        (656356768, 5),   // 58
                        (714924299, 5),   // 59
                        (777600000, 5),   // 60
                        (844596301, 5),   // 61
                        (916132832, 5),   // 62
                        (992436543, 5),   // 63
                        (0, 0),           // 64
                        (1160290625, 5),  // 65
                        (1252332576, 5),  // 66
                        (1350125107, 5),  // 67
                        (1453933568, 5),  // 68
                        (1564031349, 5),  // 69
                        (1680700000, 5),  // 70
                        (1804229351, 5),  // 71
                        (1934917632, 5),  // 72
                        (2073071593, 5),  // 73
                        (2219006624, 5),  // 74
                        (2373046875, 5),  // 75
                        (2535525376, 5),  // 76
                        (2706784157, 5),  // 77
                        (2887174368, 5),  // 78
                        (3077056399, 5),  // 79
                        (3276800000, 5),  // 80
                        (3486784401, 5),  // 81
                        (3707398432, 5),  // 82
                        (3939040643, 5),  // 83
                        (4182119424, 5),  // 84
                        (52200625, 4),    // 85
                        (54700816, 4),    // 86
                        (57289761, 4),    // 87
                        (59969536, 4),    // 88
                        (62742241, 4),    // 89
                        (65610000, 4),    // 90
                        (68574961, 4),    // 91
                        (71639296, 4),    // 92
                        (74805201, 4),    // 93
                        (78074896, 4),    // 94
                        (81450625, 4),    // 95
                        (84934656, 4),    // 96
                        (88529281, 4),    // 97
                        (92236816, 4),    // 98
                        (96059601, 4),    // 99
                        (100000000, 4),   // 100
                        (104060401, 4),   // 101
                        (108243216, 4),   // 102
                        (112550881, 4),   // 103
                        (116985856, 4),   // 104
                        (121550625, 4),   // 105
                        (126247696, 4),   // 106
                        (131079601, 4),   // 107
                        (136048896, 4),   // 108
                        (141158161, 4),   // 109
                        (146410000, 4),   // 110
                        (151807041, 4),   // 111
                        (157351936, 4),   // 112
                        (163047361, 4),   // 113
                        (168896016, 4),   // 114
                        (174900625, 4),   // 115
                        (181063936, 4),   // 116
                        (187388721, 4),   // 117
                        (193877776, 4),   // 118
                        (200533921, 4),   // 119
                        (207360000, 4),   // 120
                        (214358881, 4),   // 121
                        (221533456, 4),   // 122
                        (228886641, 4),   // 123
                        (236421376, 4),   // 124
                        (244140625, 4),   // 125
                        (252047376, 4),   // 126
                        (260144641, 4),   // 127
                        (0, 0),           // 128
                        (276922881, 4),   // 129
                        (285610000, 4),   // 130
                        (294499921, 4),   // 131
                        (303595776, 4),   // 132
                        (312900721, 4),   // 133
                        (322417936, 4),   // 134
                        (332150625, 4),   // 135
                        (342102016, 4),   // 136
                        (352275361, 4),   // 137
                        (362673936, 4),   // 138
                        (373301041, 4),   // 139
                        (384160000, 4),   // 140
                        (395254161, 4),   // 141
                        (406586896, 4),   // 142
                        (418161601, 4),   // 143
                        (429981696, 4),   // 144
                        (442050625, 4),   // 145
                        (454371856, 4),   // 146
                        (466948881, 4),   // 147
                        (479785216, 4),   // 148
                        (492884401, 4),   // 149
                        (506250000, 4),   // 150
                        (519885601, 4),   // 151
                        (533794816, 4),   // 152
                        (547981281, 4),   // 153
                        (562448656, 4),   // 154
                        (577200625, 4),   // 155
                        (592240896, 4),   // 156
                        (607573201, 4),   // 157
                        (623201296, 4),   // 158
                        (639128961, 4),   // 159
                        (655360000, 4),   // 160
                        (671898241, 4),   // 161
                        (688747536, 4),   // 162
                        (705911761, 4),   // 163
                        (723394816, 4),   // 164
                        (741200625, 4),   // 165
                        (759333136, 4),   // 166
                        (777796321, 4),   // 167
                        (796594176, 4),   // 168
                        (815730721, 4),   // 169
                        (835210000, 4),   // 170
                        (855036081, 4),   // 171
                        (875213056, 4),   // 172
                        (895745041, 4),   // 173
                        (916636176, 4),   // 174
                        (937890625, 4),   // 175
                        (959512576, 4),   // 176
                        (981506241, 4),   // 177
                        (1003875856, 4),  // 178
                        (1026625681, 4),  // 179
                        (1049760000, 4),  // 180
                        (1073283121, 4),  // 181
                        (1097199376, 4),  // 182
                        (1121513121, 4),  // 183
                        (1146228736, 4),  // 184
                        (1171350625, 4),  // 185
                        (1196883216, 4),  // 186
                        (1222830961, 4),  // 187
                        (1249198336, 4),  // 188
                        (1275989841, 4),  // 189
                        (1303210000, 4),  // 190
                        (1330863361, 4),  // 191
                        (1358954496, 4),  // 192
                        (1387488001, 4),  // 193
                        (1416468496, 4),  // 194
                        (1445900625, 4),  // 195
                        (1475789056, 4),  // 196
                        (1506138481, 4),  // 197
                        (1536953616, 4),  // 198
                        (1568239201, 4),  // 199
                        (1600000000, 4),  // 200
                        (1632240801, 4),  // 201
                        (1664966416, 4),  // 202
                        (1698181681, 4),  // 203
                        (1731891456, 4),  // 204
                        (1766100625, 4),  // 205
                        (1800814096, 4),  // 206
                        (1836036801, 4),  // 207
                        (1871773696, 4),  // 208
                        (1908029761, 4),  // 209
                        (1944810000, 4),  // 210
                        (1982119441, 4),  // 211
                        (2019963136, 4),  // 212
                        (2058346161, 4),  // 213
                        (2097273616, 4),  // 214
                        (2136750625, 4),  // 215
                        (2176782336, 4),  // 216
                        (2217373921, 4),  // 217
                        (2258530576, 4),  // 218
                        (2300257521, 4),  // 219
                        (2342560000, 4),  // 220
                        (2385443281, 4),  // 221
                        (2428912656, 4),  // 222
                        (2472973441, 4),  // 223
                        (2517630976, 4),  // 224
                        (2562890625, 4),  // 225
                        (2608757776, 4),  // 226
                        (2655237841, 4),  // 227
                        (2702336256, 4),  // 228
                        (2750058481, 4),  // 229
                        (2798410000, 4),  // 230
                        (2847396321, 4),  // 231
                        (2897022976, 4),  // 232
                        (2947295521, 4),  // 233
                        (2998219536, 4),  // 234
                        (3049800625, 4),  // 235
                        (3102044416, 4),  // 236
                        (3154956561, 4),  // 237
                        (3208542736, 4),  // 238
                        (3262808641, 4),  // 239
                        (3317760000, 4),  // 240
                        (3373402561, 4),  // 241
                        (3429742096, 4),  // 242
                        (3486784401, 4),  // 243
                        (3544535296, 4),  // 244
                        (3603000625, 4),  // 245
                        (3662186256, 4),  // 246
                        (3722098081, 4),  // 247
                        (3782742016, 4),  // 248
                        (3844124001, 4),  // 249
                        (3906250000, 4),  // 250
                        (3969126001, 4),  // 251
                        (4032758016, 4),  // 252
                        (4097152081, 4),  // 253
                        (4162314256, 4),  // 254
                        (4228250625, 4),  // 255
                        (0, 0),           // 256
                    ];

                    let (base, power) = BASES[radix as usize];
                    (base as BigDigit, power)
                }
                64 => {
                    const BASES: [(u64, usize); 257] = [
                        (0, 0),
                        (0, 0),
                        (9223372036854775808, 63),  //  2
                        (12157665459056928801, 40), //  3
                        (4611686018427387904, 31),  //  4
                        (7450580596923828125, 27),  //  5
                        (4738381338321616896, 24),  //  6
                        (3909821048582988049, 22),  //  7
                        (9223372036854775808, 21),  //  8
                        (12157665459056928801, 20), //  9
                        (10000000000000000000, 19), // 10
                        (5559917313492231481, 18),  // 11
                        (2218611106740436992, 17),  // 12
                        (8650415919381337933, 17),  // 13
                        (2177953337809371136, 16),  // 14
                        (6568408355712890625, 16),  // 15
                        (1152921504606846976, 15),  // 16
                        (2862423051509815793, 15),  // 17
                        (6746640616477458432, 15),  // 18
                        (15181127029874798299, 15), // 19
                        (1638400000000000000, 14),  // 20
                        (3243919932521508681, 14),  // 21
                        (6221821273427820544, 14),  // 22
                        (11592836324538749809, 14), // 23
                        (876488338465357824, 13),   // 24
                        (1490116119384765625, 13),  // 25
                        (2481152873203736576, 13),  // 26
                        (4052555153018976267, 13),  // 27
                        (6502111422497947648, 13),  // 28
                        (10260628712958602189, 13), // 29
                        (15943230000000000000, 13), // 30
                        (787662783788549761, 12),   // 31
                        (1152921504606846976, 12),  // 32
                        (1667889514952984961, 12),  // 33
                        (2386420683693101056, 12),  // 34
                        (3379220508056640625, 12),  // 35
                        (4738381338321616896, 12),  // 36
                        (6582952005840035281, 12),  // 37
                        (9065737908494995456, 12),  // 38
                        (12381557655576425121, 12), // 39
                        (16777216000000000000, 12), // 40
                        (550329031716248441, 11),   // 41
                        (717368321110468608, 11),   // 42
                        (929293739471222707, 11),   // 43
                        (1196683881290399744, 11),  // 44
                        (1532278301220703125, 11),  // 45
                        (1951354384207722496, 11),  // 46
                        (2472159215084012303, 11),  // 47
                        (3116402981210161152, 11),  // 48
                        (3909821048582988049, 11),  // 49
                        (4882812500000000000, 11),  // 50
                        (6071163615208263051, 11),  // 51
                        (7516865509350965248, 11),  // 52
                        (9269035929372191597, 11),  // 53
                        (11384956040305711104, 11), // 54
                        (13931233916552734375, 11), // 55
                        (16985107389382393856, 11), // 56
                        (362033331456891249, 10),   // 57
                        (430804206899405824, 10),   // 58
                        (511116753300641401, 10),   // 59
                        (604661760000000000, 10),   // 60
                        (713342911662882601, 10),   // 61
                        (839299365868340224, 10),   // 62
                        (984930291881790849, 10),   // 63
                        (1152921504606846976, 10),  // 64
                        (1346274334462890625, 10),  // 65
                        (1568336880910795776, 10),  // 66
                        (1822837804551761449, 10),  // 67
                        (2113922820157210624, 10),  // 68
                        (2446194060654759801, 10),  // 69
                        (2824752490000000000, 10),  // 70
                        (3255243551009881201, 10),  // 71
                        (3743906242624487424, 10),  // 72
                        (4297625829703557649, 10),  // 73
                        (4923990397355877376, 10),  // 74
                        (5631351470947265625, 10),  // 75
                        (6428888932339941376, 10),  // 76
                        (7326680472586200649, 10),  // 77
                        (8335775831236199424, 10),  // 78
                        (9468276082626847201, 10),  // 79
                        (10737418240000000000, 10), // 80
                        (12157665459056928801, 10), // 81
                        (13744803133596058624, 10), // 82
                        (15516041187205853449, 10), // 83
                        (17490122876598091776, 10), // 84
                        (231616946283203125, 9),    // 85
                        (257327417311663616, 9),    // 86
                        (285544154243029527, 9),    // 87
                        (316478381828866048, 9),    // 88
                        (350356403707485209, 9),    // 89
                        (387420489000000000, 9),    // 90
                        (427929800129788411, 9),    // 91
                        (472161363286556672, 9),    // 92
                        (520411082988487293, 9),    // 93
                        (572994802228616704, 9),    // 94
                        (630249409724609375, 9),    // 95
                        (692533995824480256, 9),    // 96
                        (760231058654565217, 9),    // 97
                        (833747762130149888, 9),    // 98
                        (913517247483640899, 9),    // 99
                        (1000000000000000000, 9),   // 100
                        (1093685272684360901, 9),   // 101
                        (1195092568622310912, 9),   // 102
                        (1304773183829244583, 9),   // 103
                        (1423311812421484544, 9),   // 104
                        (1551328215978515625, 9),   // 105
                        (1689478959002692096, 9),   // 106
                        (1838459212420154507, 9),   // 107
                        (1999004627104432128, 9),   // 108
                        (2171893279442309389, 9),   // 109
                        (2357947691000000000, 9),   // 110
                        (2558036924386500591, 9),   // 111
                        (2773078757450186752, 9),   // 112
                        (3004041937984268273, 9),   // 113
                        (3251948521156637184, 9),   // 114
                        (3517876291919921875, 9),   // 115
                        (3802961274698203136, 9),   // 116
                        (4108400332687853397, 9),   // 117
                        (4435453859151328768, 9),   // 118
                        (4785448563124474679, 9),   // 119
                        (5159780352000000000, 9),   // 120
                        (5559917313492231481, 9),   // 121
                        (5987402799531080192, 9),   // 122
                        (6443858614676334363, 9),   // 123
                        (6930988311686938624, 9),   // 124
                        (7450580596923828125, 9),   // 125
                        (8004512848309157376, 9),   // 126
                        (8594754748609397887, 9),   // 127
                        (9223372036854775808, 9),   // 128
                        (9892530380752880769, 9),   // 129
                        (10604499373000000000, 9),  // 130
                        (11361656654439817571, 9),  // 131
                        (12166492167065567232, 9),  // 132
                        (13021612539908538853, 9),  // 133
                        (13929745610903012864, 9),  // 134
                        (14893745087865234375, 9),  // 135
                        (15916595351771938816, 9),  // 136
                        (17001416405572203977, 9),  // 137
                        (18151468971815029248, 9),  // 138
                        (139353667211683681, 8),    // 139
                        (147578905600000000, 8),    // 140
                        (156225851787813921, 8),    // 141
                        (165312903998914816, 8),    // 142
                        (174859124550883201, 8),    // 143
                        (184884258895036416, 8),    // 144
                        (195408755062890625, 8),    // 145
                        (206453783524884736, 8),    // 146
                        (218041257467152161, 8),    // 147
                        (230193853492166656, 8),    // 148
                        (242935032749128801, 8),    // 149
                        (256289062500000000, 8),    // 150
                        (270281038127131201, 8),    // 151
                        (284936905588473856, 8),    // 152
                        (300283484326400961, 8),    // 153
                        (316348490636206336, 8),    // 154
                        (333160561500390625, 8),    // 155
                        (350749278894882816, 8),    // 156
                        (369145194573386401, 8),    // 157
                        (388379855336079616, 8),    // 158
                        (408485828788939521, 8),    // 159
                        (429496729600000000, 8),    // 160
                        (451447246258894081, 8),    // 161
                        (474373168346071296, 8),    // 162
                        (498311414318121121, 8),    // 163
                        (523300059815673856, 8),    // 164
                        (549378366500390625, 8),    // 165
                        (576586811427594496, 8),    // 166
                        (604967116961135041, 8),    // 167
                        (634562281237118976, 8),    // 168
                        (665416609183179841, 8),    // 169
                        (697575744100000000, 8),    // 170
                        (731086699811838561, 8),    // 171
                        (765997893392859136, 8),    // 172
                        (802359178476091681, 8),    // 173
                        (840221879151902976, 8),    // 174
                        (879638824462890625, 8),    // 175
                        (920664383502155776, 8),    // 176
                        (963354501121950081, 8),    // 177
                        (1007766734259732736, 8),   // 178
                        (1053960288888713761, 8),   // 179
                        (1101996057600000000, 8),   // 180
                        (1151936657823500641, 8),   // 181
                        (1203846470694789376, 8),   // 182
                        (1257791680575160641, 8),   // 183
                        (1313840315232157696, 8),   // 184
                        (1372062286687890625, 8),   // 185
                        (1432529432742502656, 8),   // 186
                        (1495315559180183521, 8),   // 187
                        (1560496482665168896, 8),   // 188
                        (1628150074335205281, 8),   // 189
                        (1698356304100000000, 8),   // 190
                        (1771197285652216321, 8),   // 191
                        (1846757322198614016, 8),   // 192
                        (1925122952918976001, 8),   // 193
                        (2006383000160502016, 8),   // 194
                        (2090628617375390625, 8),   // 195
                        (2177953337809371136, 8),   // 196
                        (2268453123948987361, 8),   // 197
                        (2362226417735475456, 8),   // 198
                        (2459374191553118401, 8),   // 199
                        (2560000000000000000, 8),   // 200
                        (2664210032449121601, 8),   // 201
                        (2772113166407885056, 8),   // 202
                        (2883821021683985761, 8),   // 203
                        (2999448015365799936, 8),   // 204
                        (3119111417625390625, 8),   // 205
                        (3242931408352297216, 8),   // 206
                        (3371031134626313601, 8),   // 207
                        (3503536769037500416, 8),   // 208
                        (3640577568861717121, 8),   // 209
                        (3782285936100000000, 8),   // 210
                        (3928797478390152481, 8),   // 211
                        (4080251070798954496, 8),   // 212
                        (4236788918503437921, 8),   // 213
                        (4398556620369715456, 8),   // 214
                        (4565703233437890625, 8),   // 215
                        (4738381338321616896, 8),   // 216
                        (4916747105530914241, 8),   // 217
                        (5100960362726891776, 8),   // 218
                        (5291184662917065441, 8),   // 219
                        (5487587353600000000, 8),   // 220
                        (5690339646868044961, 8),   // 221
                        (5899616690476974336, 8),   // 222
                        (6115597639891380481, 8),   // 223
                        (6338465731314712576, 8),   // 224
                        (6568408355712890625, 8),   // 225
                        (6805617133840466176, 8),   // 226
                        (7050287992278341281, 8),   // 227
                        (7302621240492097536, 8),   // 228
                        (7562821648920027361, 8),   // 229
                        (7831098528100000000, 8),   // 230
                        (8107665808844335041, 8),   // 231
                        (8392742123471896576, 8),   // 232
                        (8686550888106661441, 8),   // 233
                        (8989320386052055296, 8),   // 234
                        (9301283852250390625, 8),   // 235
                        (9622679558836781056, 8),   // 236
                        (9953750901796946721, 8),   // 237
                        (10294746488738365696, 8),  // 238
                        (10645920227784266881, 8),  // 239
                        (11007531417600000000, 8),  // 240
                        (11379844838561358721, 8),  // 241
                        (11763130845074473216, 8),  // 242
                        (12157665459056928801, 8),  // 243
                        (12563730464589807616, 8),  // 244
                        (12981613503750390625, 8),  // 245
                        (13411608173635297536, 8),  // 246
                        (13854014124583882561, 8),  // 247
                        (14309137159611744256, 8),  // 248
                        (14777289335064248001, 8),  // 249
                        (15258789062500000000, 8),  // 250
                        (15753961211814252001, 8),  // 251
                        (16263137215612256256, 8),  // 252
                        (16786655174842630561, 8),  // 253
                        (17324859965700833536, 8),  // 254
                        (17878103347812890625, 8),  // 255
                        (72057594037927936, 7),     // 256
                    ];

                    let (base, power) = BASES[radix as usize];
                    (base as BigDigit, power)
                }
                _ => panic!("Invalid bigdigit size"),
            }
        }

        #[inline]
        fn adc(a: BigDigit, b: BigDigit, acc: &mut DoubleBigDigit) -> BigDigit {
            *acc += a as DoubleBigDigit;
            *acc += b as DoubleBigDigit;
            let lo = *acc as BigDigit;
            *acc >>= big_digit::BITS;
            lo
        }

        #[inline]
        pub fn __add2(a: &mut [BigDigit], b: &[BigDigit]) -> BigDigit {
            debug_assert!(a.len() >= b.len());

            let mut carry = 0;
            let (a_lo, a_hi) = a.split_at_mut(b.len());

            for (a, b) in a_lo.iter_mut().zip(b) {
                *a = adc(*a, *b, &mut carry);
            }

            if carry != 0 {
                for a in a_hi {
                    *a = adc(*a, 0, &mut carry);
                    if carry == 0 {
                        break;
                    }
                }
            }

            carry as BigDigit
        }

        pub fn add2(a: &mut [BigDigit], b: &[BigDigit]) {
            let carry = __add2(a, b);

            debug_assert!(carry == 0);
        }

        #[inline]
        pub fn mac_with_carry(
            a: BigDigit,
            b: BigDigit,
            c: BigDigit,
            acc: &mut DoubleBigDigit,
        ) -> BigDigit {
            *acc += a as DoubleBigDigit;
            *acc += (b as DoubleBigDigit) * (c as DoubleBigDigit);
            let lo = *acc as BigDigit;
            *acc >>= big_digit::BITS;
            lo
        }

        impl BigUint {
            fn from_str_radix(s: &str, radix: u32) -> Result<BigUint, ParseBigIntError> {
                assert!(2 <= radix && radix <= 36, "The radix must be within 2...36");
                let mut s = s;
                if s.starts_with('+') {
                    let tail = &s[1..];
                    if !tail.starts_with('+') {
                        s = tail
                    }
                }

                if s.is_empty() {
                    return Err(ParseBigIntError::Empty);
                }

                if s.starts_with('_') {
                    // Must lead with a real digit!
                    return Err(ParseBigIntError::Invalid);
                }

                // First normalize all characters to plain digit values
                let mut v = Vec::with_capacity(s.len());
                for b in s.bytes() {
                    let d = match b {
                        b'0'...b'9' => b - b'0',
                        b'a'...b'z' => b - b'a' + 10,
                        b'A'...b'Z' => b - b'A' + 10,
                        b'_' => continue,
                        _ => u8::max_value(),
                    };
                    if d < radix as u8 {
                        v.push(d);
                    } else {
                        return Err(ParseBigIntError::Invalid);
                    }
                }

                let res = from_radix_digits_be(&v, radix);
                Ok(res)
            }

            pub fn parse_bytes(buf: &[u8], radix: u32) -> Option<BigUint> {
                use std::str;
                str::from_utf8(buf)
                    .ok()
                    .and_then(|s| BigUint::from_str_radix(s, radix).ok())
            }

            #[inline]
            pub fn new(digits: Vec<BigDigit>) -> BigUint {
                BigUint { data: digits }.normalized()
            }

            #[inline]
            fn normalize(&mut self) {
                while let Some(&0) = self.data.last() {
                    self.data.pop();
                }
            }

            #[inline]
            fn normalized(mut self) -> BigUint {
                self.normalize();
                self
            }

            #[inline]
            pub fn to_radix_le(&self, radix: u32) -> Vec<u8> {
                to_radix_le(self, radix)
            }

            #[inline]
            fn is_zero(&self) -> bool {
                self.data.is_empty()
            }

            #[inline]
            pub fn bits(&self) -> usize {
                if self.is_zero() {
                    return 0;
                }
                let zeros = self.data.last().unwrap().leading_zeros();
                return self.data.len() * big_digit::BITS - zeros as usize;
            }
        }

        pub fn to_radix_le(u: &BigUint, radix: u32) -> Vec<u8> {
            if u.is_zero() {
                vec![0]
            } else if radix == 27 {
                to_radix_digits_le(u, 27)
            } else {
                to_radix_digits_le(u, radix)
            }
        }

        pub fn div_rem_digit(mut a: BigUint, b: BigDigit) -> (BigUint, BigDigit) {
            let mut rem = 0;

            for d in a.data.iter_mut().rev() {
                let (q, r) = div_wide(rem, *d, b);
                *d = q;
                rem = r;
            }

            (a.normalized(), rem)
        }

        #[inline]
        fn div_wide(hi: BigDigit, lo: BigDigit, divisor: BigDigit) -> (BigDigit, BigDigit) {
            debug_assert!(hi < divisor);

            let lhs = big_digit::to_doublebigdigit(hi, lo);
            let rhs = divisor as DoubleBigDigit;
            ((lhs / rhs) as BigDigit, (lhs % rhs) as BigDigit)
        }

        #[inline(always)]
        fn to_radix_digits_le(u: &BigUint, radix: u32) -> Vec<u8> {
            debug_assert!(!u.is_zero() && !radix.is_power_of_two());

            let radix_digits = ((u.bits() as f64) / (radix as f64).log2()).ceil();
            let mut res = Vec::with_capacity(radix_digits as usize);
            let mut digits = u.clone();

            let (base, power) = get_radix_base(radix);
            let radix = radix as BigDigit;

            while digits.data.len() > 1 {
                let (q, mut r) = div_rem_digit(digits, base);
                for _ in 0..power {
                    res.push((r % radix) as u8);
                    r /= radix;
                }
                digits = q;
            }

            let mut r = digits.data[0];
            while r != 0 {
                res.push((r % radix) as u8);
                r /= radix;
            }

            res
        }
    }

    #[inline(always)]
    fn f(x: UInt) -> UInt {
        (x * 33 + 1) % MOD
    }

    fn precompute_f_for_slice(cols: &mut [UInt]) {
        let mut c = 0;
        for v in cols.iter_mut() {
            *v = f(c);
            c = *v;
        }
    }

    fn compute_sums_pwr_2<'a, 'b>(
        table_size: u64,
        f: &[UInt],
        mut buffer1: Vec<UInt>,
        mut buffer2: Vec<UInt>,
        first_row: u64,
        rows_log2: u64,
    ) -> (Vec<UInt>, Vec<UInt>) {
        for (idx, dst) in buffer2.iter_mut().enumerate() {
            *dst =
                *unsafe { f.get_unchecked((idx as u64 + table_size * first_row) as usize % MODUS) };
        }
        for c in 0..rows_log2 {
            for (idx, dst) in buffer1.iter_mut().enumerate() {
                *dst = *unsafe { buffer2.get_unchecked(idx) } + *unsafe {
                    buffer2.get_unchecked((idx as u64 + table_size * (1 << c)) as usize % MODUS)
                };
            }
            ::std::mem::swap(&mut buffer1, &mut buffer2);
        }
        (buffer2, buffer1)
    }

    pub fn make_pad(table_size: u32, cypher_len: u32) -> Vec<u8> {
        let cols = {
            let mut f: Vec<UInt> = vec![0; MOD as usize];
            precompute_f_for_slice(&mut f);

            let mut totals: Vec<UInt> = vec![0; MOD as usize];
            let mut buffer1: Vec<UInt> = vec![0; MOD as usize];
            let mut buffer2: Vec<UInt> = vec![0; MOD as usize];

            let mut n = table_size as u64;
            let mut row = 0_u64;
            let mut rows_log2 = 63_u64;

            while n != 0 {
                if n & 0x8000000000000000_u64 == 0x8000000000000000 {
                    let (buf1, buf2) = compute_sums_pwr_2(
                        table_size as u64,
                        &mut f,
                        buffer1,
                        buffer2,
                        row,
                        rows_log2,
                    );
                    for (dst, src) in totals.iter_mut().zip(buf1.iter()) {
                        *dst += *src;
                    }
                    buffer1 = buf1;
                    buffer2 = buf2;

                    row += 1 << rows_log2;
                }
                rows_log2 -= 1;
                n <<= 1;
            }

            let mut cols: Vec<UInt> = vec![0; table_size as usize];
            for (idx, c) in cols.iter_mut().enumerate() {
                *c = unsafe { totals.get_unchecked(idx % MODUS) } % MOD;
            }
            cols
        };

        let pad = {
            use std::fmt::Write;
            let mut bignum_str = String::new();
            for n in &cols {
                write!(bignum_str, "{}", n).unwrap();
            }
            let bi = big::BigUint::parse_bytes(bignum_str.as_bytes(), 10).unwrap();
            let mut pad = bi.to_radix_le(27);
            pad
        };

        pad.into_iter().rev().take(cypher_len as usize).collect()
    }

    fn ascii_to_code(c: char) -> u8 {
        match c {
            'A'..='Z' => c as u8 - 'A' as u8,
            ' ' => 26,
            _ => panic!("Invalid input - must be of class [A-Z ]"),
        }
    }

    fn base27_to_ascii(c: u8) -> u8 {
        match c {
            0..=25 => (c + 'A' as u8),
            26 => ' ' as u8,
            _ => panic!("Invalid codepoint - must be 0 to 26, inclusive"),
        }
    }

    pub fn decode(encoded: &str, pad: &[u8], out: &mut io::Write) {
        assert_eq!(
            encoded.as_bytes().len(),
            pad.len(),
            "need pad len to be encoded bytes length, which must be ascii"
        );

        for (c, p) in encoded.chars().map(ascii_to_code).zip(pad) {
            let base27 = (c + p) % BASE;
            out.write(&[base27_to_ascii(base27)]).unwrap();
        }
        out.write(&['\n' as u8]).unwrap();
    }
}

fn main() -> Result<(), parse::Error> {
    let (stdin, stdout) = (stdin(), stdout());
    let (mut stdin_lock, stdout_lock) = (stdin.lock(), stdout.lock());
    let mut writer = BufWriter::new(stdout_lock);

    let mut first_line = String::new();
    let mut second_line = String::new();
    stdin_lock.read_line(&mut first_line)?;
    stdin_lock.read_line(&mut second_line)?;

    match (first_line.len(), second_line.len()) {
        (0, 0) | (_, 0) => {
            eprintln!("input exhausted prematurely");
            process::exit(2)
        }
        _ => {
            let (cypher_len, table_size) = parse::dimensions(&first_line)?;
            let cypher_text = parse::validated_cypher_text(&second_line, cypher_len)?;
            assert!(
                cypher_len as usize == cypher_text.len(),
                "cipher text was not as long or longer than advertised"
            );

            let pad = crypt::make_pad(table_size, cypher_len);
            crypt::decode(&cypher_text, &pad, &mut writer);
            writer.flush().unwrap();
        }
    }
    Ok(())
}
